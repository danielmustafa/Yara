//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API {

    /**
    Search Recipes by Ingredients

            Ever wondered what recipes you can cook with the ingredients you have in your fridge or pantry? This endpoint lets you find recipes that either maximize the usage of ingredients you have at hand (pre shopping) or minimize the ingredients that you don't currently have (post shopping).
    */
    public enum SearchRecipesByIngredients {

        public static let service = APIService<Response>(id: "searchRecipesByIngredients", tag: "", method: "GET", path: "/recipes/findByIngredients", hasBody: false, securityRequirements: [SecurityRequirement(type: "apiKeyScheme", scopes: [])])

        public final class Request: APIRequest<Response> {

            public struct Options {

                /** A comma-separated list of ingredients that the recipes should contain. */
                public var ingredients: String

                /** The maximum number of recipes to return (between 1 and 100). Defaults to 10. */
                public var number: Double?

                /** Whether the recipes should have an open license that allows display with proper attribution. */
                public var limitLicense: Bool?

                /** Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. */
                public var ranking: Double?

                /** Whether to ignore typical pantry items, such as water, salt, flour, etc. */
                public var ignorePantry: Bool?

                public init(ingredients: String, number: Double? = nil, limitLicense: Bool? = nil, ranking: Double? = nil, ignorePantry: Bool? = nil) {
                    self.ingredients = ingredients
                    self.number = number
                    self.limitLicense = limitLicense
                    self.ranking = ranking
                    self.ignorePantry = ignorePantry
                }
            }

            public var options: Options

            public init(options: Options) {
                self.options = options
                super.init(service: SearchRecipesByIngredients.service)
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(ingredients: String, number: Double? = nil, limitLicense: Bool? = nil, ranking: Double? = nil, ignorePantry: Bool? = nil) {
                let options = Options(ingredients: ingredients, number: number, limitLicense: limitLicense, ranking: ranking, ignorePantry: ignorePantry)
                self.init(options: options)
            }

            public override var queryParameters: [String: Any] {
                var params: [String: Any] = [:]
                params["ingredients"] = options.ingredients
                if let number = options.number {
                  params["number"] = number
                }
                if let limitLicense = options.limitLicense {
                  params["limitLicense"] = limitLicense
                }
                if let ranking = options.ranking {
                  params["ranking"] = ranking
                }
                if let ignorePantry = options.ignorePantry {
                  params["ignorePantry"] = ignorePantry
                }
                return params
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {
            public typealias SuccessType = [String: Any]

            /** Success */
            case status200([String: Any])

            /** Unauthorized */
            case status401

            /** Forbidden */
            case status403

            /** Not Found */
            case status404

            public var success: [String: Any]? {
                switch self {
                case .status200(let response): return response
                default: return nil
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                default: return ()
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                case .status401: return 401
                case .status403: return 403
                case .status404: return 404
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                case .status401: return false
                case .status403: return false
                case .status404: return false
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decodeAny([String: Any].self, from: data))
                case 401: self = .status401
                case 403: self = .status403
                case 404: self = .status404
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
